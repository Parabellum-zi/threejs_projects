{"version":3,"file":"OpacityPipe.f3016ef3.js","sources":["../../src/components/OpacityPipe.vue"],"sourcesContent":["<template>\n  <div id=\"sceneContainer\" ref=\"sceneContainer\"></div>\n</template>\n\n<script setup>\nimport { onMounted, reactive, ref } from \"vue\";\nimport * as dat from \"dat.gui\";\nimport * as THREE from \"three\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport threeUniversal from \"../utils/threeUniversal\";\nimport ResourceTracker from \"../utils/ResourceTracker\";\nimport Base3D from \"../utils/base3D\";\nlet scene = reactive({});\nlet camera = reactive({});\n// let renderer = reactive({});\n// let orbitControls = reactive({});\nconst sceneContainer = ref(null);\nlet gui;\nlet material;\n// let clock = new THREE.Clock();\nconst pointsArr = [\n  [-80, -20, 0],\n  [-70, 20, 0],\n  [0, 0, 0],\n  [70, 30, 0],\n  [20, 40, 0],\n];\n/*\nconst pointsArr = [\n  [113.33200717035561, 23.123868298337488, 20],\n  [113.33193471797097, 23.12389375632453, 20],\n  [113.33187953734473, 23.123770177383715, 20],\n  [113.33185832872239, 23.123481594596804, 20],\n  [113.33169725322034, 23.12263653054203, 20],\n  [113.3319550555247, 23.122622333204134, 20],\n  [113.33223498079862, 23.12261203308015, 20],\n  [113.33252478587465, 23.122587171140765, 20],\n  [113.3327903879739, 23.122589532743206, 20],\n  [113.33300847557683, 23.12258577162446, 20],\n  [113.33322488273681, 23.122574663006855, 20],\n  [113.33325226582443, 23.122530909194133, 20],\n  [113.3332644228248, 23.122309951803306, 20],\n  [113.33325917485871, 23.12204813100512, 20],\n  [113.3332602085735, 23.121777588490747, 20],\n  [113.33326582366728, 23.12153099095903, 20],\n  [113.33326443507165, 23.12145409799167, 20],\n  [113.33327543328967, 23.121325676116662, 20],\n  [113.33347832991453, 23.12131401426879, 20],\n  [113.33376506377276, 23.121288358975708, 20],\n  [113.33404731471101, 23.121263662071076, 20],\n  [113.33428435196257, 23.12123652778491, 20],\n  [113.33444257785685, 23.12108209002754, 20],\n  [113.33444245620335, 23.12082534299868, 20],\n  [113.33443698584692, 23.12054420347713, 20],\n  [113.33443361968887, 23.12031888058382, 20],\n  [113.33443122026354, 23.120002662765, 20],\n  [113.33442693344298, 23.11972456728798, 20],\n  [113.3344232242018, 23.119552454790348, 20],\n  [113.33453681602084, 23.119526738111013, 20],\n  [113.33475147734951, 23.119489872823163, 20],\n  [113.33512287057088, 23.11944253470876, 20],\n  [113.33565136182612, 23.11937221691412, 20],\n  [113.33648041097598, 23.118473519373225, 20],\n  [113.33648800266937, 23.118457139717187, 20],\n];\n*/\n\nlet texture;\nconst resMgr = new ResourceTracker();\nconst track = resMgr.track.bind(resMgr);\n\nlet data = reactive({\n  base3D: {},\n});\n\nonMounted(() => {\n  initScene();\n  iterativeScene();\n  animate();\n});\n\nfunction initScene() {\n  data.base3D = new Base3D(sceneContainer.value);\n  threeUniversal.addFloor(data.base3D.scene);\n  // document.addEventListener(\"mousedown\", onDocumentMouseDown);\n}\n\nfunction animate(time) {\n  time *= 0.001;\n  texture.offset.x = -(time * 1) % 1; // 贴图运动速度\n  // const elapsedTime = clock.getElapsedTime();\n  requestAnimationFrame(animate);\n}\n\nfunction initPipeConf() {\n  const transparentConf = {\n    points: pointsArr,\n    color: 0x4488ff,\n    radius: 3,\n    opacity: 0.1,\n  };\n\n  // 管道内流动的液体\n  const conf = {\n    points: pointsArr,\n    texture: \"images/allow2.png\",\n    radius: 1.5,\n  };\n  // 创建管道\n  const { texture: tubeTexture0, mesh: pipe0 } = creatPipe(transparentConf);\n  const { texture: tubeTexture1, mesh: pipe1 } = creatPipe(conf);\n  texture = tubeTexture1;\n  data.base3D.scene.add(track(pipe0));\n  data.base3D.scene.add(track(pipe1));\n  // console.log(scene);\n  // return { tubeTexture1 };\n\n  // var radius = data[i][\"Diameter\"] - 0; // 管子的半径\n  /*\n  var radius = 3; // 管子的半径\n  var shape = new THREE.Shape();\n  shape.absarc(0, 0, radius, 0, Math.PI * 2, false);\n\n  var material = new THREE.MeshBasicMaterial({ color: 0xff0000 });\n\n  var v1 = new THREE.Vector3(0, 0, 0);\n  var v2 = new THREE.Vector3(100, 0, 0);\n\n  var path = new THREE.LineCurve3(v1, v2);\n\n  var extrudeSettings = {\n    bevelEnabled: false,\n    steps: 1,\n    extrudePath: path,\n  };\n\n  var geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);\n  var mesh = new THREE.Mesh(geometry, material);\n  scene.add(mesh);\n*/\n\n  /*  let bb = [\n    [-10, 0, 0],\n    [0, 10, 0],\n    [10, 0, 0],\n  ];\n\n  let aa = {\n    points: bb,\n  };\n\n  const material1 = new THREE.LineBasicMaterial({\n    color: 0x0000ff,\n  });\n\n  // points.push(new THREE.Vector3(-10, 0, 0));\n  // points.push(new THREE.Vector3(0, 10, 0));\n  // points.push(new THREE.Vector3(10, 0, 0));\n  // console.log(points);\n  const geometry = new THREE.BufferGeometry().setFromPoints(aa.points);\n  creatPipe(aa);\n  const line = new THREE.Line(geometry, material1);\n  scene.add(line);*/\n  /* var point1 = new THREE.Vector3(4, 8, 9);\n\n  var geometry = new THREE.Geometry();\n  //定义线的颜色\n  // Parameters是一个定义材质外观的对象，它包含多个属性来定义材质，这些属性是：\n  // Color：线条的颜色，用16进制来表示，默认的颜色是白色。\n  // linewidth：线条的宽度，默认时候1个单位宽度。 这个参数设置了也没用\n  // Linecap：线条两端的外观，默认是圆角端点，当线条较粗的时候才看得出效果，如果线条很细，那么你几乎看不出效果了。\n  // Linejoin：两个线条的连接点处的外观，默认是“round”，表示圆角。\n  // VertexColors：定义线条材质是否使用顶点颜色，这是一个boolean值。意思是，线条各部分的颜色会根据顶点的颜色来进行插值。\n  // Fog：定义材质的颜色是否受全局雾效的影响。\n  var material = new THREE.LineBasicMaterial({\n    vertexColors: false,\n    color: 0xff0000,\n  });\n  var color1 = new THREE.Color(0xff0000);\n  let color2 = new THREE.Color(0xffff00);\n  // 创建点，此处创建并放到几何体里面两个点，是一条线段，三个点是一条折现\n  var p1 = new THREE.Vector3(-100, 0, 100);\n  var p2 = new THREE.Vector3(100, 0, -100);\n  var p3 = new THREE.Vector3(100, 0, 100);\n  geometry.vertices.push(p1);\n  geometry.vertices.push(p2);\n  geometry.vertices.push(p3);\n  //创建线   THREE.LineSegments 这个方法是创建线段的意思 有些文章里面 写的是THREE.LinePieces  但是在84版以后（我用的84版和107版）都不在支持了\n  var line = new THREE.Line(geometry, material, THREE.LineSegments);\n  //加入到场景\n  scene.add(line);*/\n\n  /*  var p1 = new THREE.Vector3(-85.35, -35.36, 0);\n  var p2 = new THREE.Vector3(-50, 0, 0);\n  var p3 = new THREE.Vector3(0, 50, 0);\n  var p4 = new THREE.Vector3(50, 0, 0);\n  var p5 = new THREE.Vector3(85.35, -35.36, 0);\n  // 创建线条一：直线\n  let line1 = new THREE.LineCurve3(p1, p2);\n  // 重建线条2：三维样条曲线\n  var curve = new THREE.CatmullRomCurve3([p2, p3, p4]);\n  // 创建线条3：直线\n  let line2 = new THREE.LineCurve3(p4, p5);\n  var CurvePath = new THREE.CurvePath(); // 创建CurvePath对象\n  CurvePath.curves.push(line1, curve, line2); // 插入多段线条\n  //通过多段曲线路径创建生成管道\n  //通过多段曲线路径创建生成管道，CCurvePath：管道路径\n  var geometry2 = new THREE.TubeGeometry(CurvePath, 100, 5, 25, false);\n  var material = new THREE.MeshLambertMaterial({});\n  material.map = textloader.load(\"../images/netline-on.jpg\");\n  material.map.wrapS = material.map.wrapT = THREE.RepeatWrapping;\n  material.map.needsUpdate = true;\n  var cube = new THREE.Mesh(geometry2, material);\n  cube.spead = 0.01;\n  cube.position.y = 300;\n  aaa.push(cube);\n  console.log(cube);\n  scene.add(cube);*/\n\n  /* let stripMesh;\n  // 管中心平面\n  const stripGeo = new THREE.PlaneGeometry(50, 100);\n  const stripMat = new THREE.MeshBasicMaterial({\n    map: texture,\n    opacity: 1,\n    side: THREE.DoubleSide,\n    depthWrite: false,\n    depthTest: false,\n    transparent: true,\n  });\n  stripMesh = new THREE.Mesh(stripGeo, stripMat);\n  scene.add(stripMesh);*/\n  // stripMesh.rotation.z = Math.PI * 0.5;\n  // stripMesh.rotation.y = Math.PI * 0.5;\n  // stripMesh.rotation.x = Math.PI * 0.5;\n\n  return { tubeTexture0, tubeTexture1 };\n  // return { tubeTexture1 };\n}\n\n/**\n * 创建文本贴图\n * @param text\n * @returns {HTMLCanvasElement}\n */\nfunction getTextCanvas(text) {\n  let width = 512,\n    height = 256;\n  let canvas = document.createElement(\"canvas\");\n  canvas.width = width;\n  canvas.height = height;\n  let ctx = canvas.getContext(\"2d\");\n  // ctx.fillStyle = \"rgba(76,180,206,0.1)\";\n  ctx.fillStyle = \"rgba(241,11,11,0.2)\";\n  ctx.fillRect(0, 0, width, height);\n  ctx.font = 500 + 'px \"sans-serif';\n  ctx.fillStyle = \"rgba(40,145,255,1)\";\n  ctx.textAlign = \"center\";\n  ctx.textBaseline = \"middle\";\n  ctx.fillText(text, width / 2, height / 2);\n  return canvas;\n}\n\n//初始化dat.GUI简化试验流程\nfunction initGui() {\n  //声明一个保存需求修改的相关数据的对象\n  gui = {\n    offsetX: 0,\n    offsetY: 0,\n    repeatX: 1,\n    repeatY: 1,\n    rotation: 0,\n    centerX: 0.5,\n    centerY: 0.5,\n    RepeatWrapping: true,\n  };\n  let datGui = new dat.GUI();\n  //将设置属性添加到gui当中，gui.add(对象，属性，最小值，最大值）\n  datGui.add(gui, \"offsetX\", 0.0, 1.0).onChange(updateUV);\n  datGui.add(gui, \"offsetY\", 0.0, 1.0).onChange(updateUV);\n  datGui.add(gui, \"repeatX\", 0.25, 2.0).onChange(updateUV);\n  datGui.add(gui, \"repeatY\", 0.25, 2.0).onChange(updateUV);\n  datGui.add(gui, \"rotation\", -2.0, 2.0).onChange(updateUV);\n  datGui.add(gui, \"centerX\", 0.0, 1.0).onChange(updateUV);\n  datGui.add(gui, \"centerY\", 0.0, 1.0).onChange(updateUV);\n  datGui.add(gui, \"RepeatWrapping\").onChange(function (e) {\n    if (e) {\n      material.map.wrapS = material.map.wrapT = THREE.RepeatWrapping; //设置为可循环\n    } else {\n      material.map.wrapS = material.map.wrapT = THREE.ClampToEdgeWrapping; //设置会默认的最后一像素伸展\n    }\n\n    material.map.needsUpdate = true;\n  });\n}\n\n//更新纹理贴图的方法\nfunction updateUV() {\n  // 一种方法，直接全写在一个方法内\n  //texture.matrix.setUvTransform( API.offsetX, API.offsetY, API.repeatX, API.repeatY, API.rotation, API.centerX, API.centerY );\n\n  // 另一种方法，分开写\n  material.map.matrix\n    .identity() //矩阵重置\n    .translate(-gui.centerX, -gui.centerY) //设置中心点\n    .rotate(gui.rotation) // 旋转\n    .scale(gui.repeatX, gui.repeatY) //缩放\n    .translate(gui.centerX, gui.centerY) //设置中心点\n    .translate(gui.offsetX, gui.offsetY); //偏移\n}\n\n/**\n *  创建管线\n *  https://threejs.org/docs/index.html?q=TubeGeometry#api/en/geometries/TubeGeometry\n */\nfunction creatPipe(conf) {\n  const path = createPath(conf.points);\n  const geometry = track(\n    new THREE.TubeGeometry(path, 100, conf.radius, 15, false)\n  );\n\n  const textureLoader = new THREE.TextureLoader();\n  let material;\n\n  if (conf.texture !== undefined) {\n    texture = textureLoader.load(conf.texture); // 图片贴图\n    // texture = new THREE.CanvasTexture(getTextCanvas(\"➯ ➮ ➯\")); // 文本贴图\n    // 设置阵列模式为 RepeatWrapping\n    texture.wrapS = THREE.RepeatWrapping;\n    texture.wrapT = THREE.RepeatWrapping;\n    // 设置x方向的偏移(沿着管道路径方向)，y方向默认1\n    // 等价texture.repeat= new THREE.Vector2(3,1)\n    texture.repeat.set(10, 1);\n    // texture.rotation = Math.PI;\n    // 图片贴图\n    // 模拟管线运动动画，将两个素材图按比例合并，然后生成贴图texture\n    material = track(\n      new THREE.MeshPhongMaterial({\n        map: texture,\n        transparent: true,\n        depthTest: false, // 深度检测\n      })\n    );\n\n    //尝试使用文本贴图\n    /*    material = new THREE.MeshBasicMaterial({\n      map: texture,\n      transparent: true,\n      opacity: 1,\n      color: conf.color,\n    });*/\n  } else {\n    material = track(\n      new THREE.MeshPhongMaterial({\n        // map: texture,\n        color: conf.color,\n        transparent: true,\n        opacity: conf.opacity,\n        depthWrite: false, // 为true内部流动的液体会被遮挡无法显示\n      })\n    );\n  }\n  const mesh = track(new THREE.Mesh(geometry, material));\n  // mesh.rotation.z = Math.PI * 0.5; // 箭头方向\n  mesh.rotation.x = Math.PI * 0.5; //修改箭头在管壁的位置\n\n  return { texture, mesh };\n}\n\nfunction createPath(pointsArr) {\n  pointsArr = pointsArr.map((point) => new THREE.Vector3(...point));\n  // 利用CatmullRomCurve3 创建路径，不过是平滑的三维样条曲线\n  return new THREE.CatmullRomCurve3(pointsArr);\n}\n\nfunction onDocumentMouseDown(event) {\n  event.preventDefault();\n  let vector = new THREE.Vector3(); //三维坐标对象\n  vector.set(\n    (event.clientX / window.innerWidth) * 2 - 1,\n    -(event.clientY / window.innerHeight) * 2 + 1,\n    0.5\n  );\n  vector.unproject(camera);\n  let rayCaster = new THREE.Raycaster(\n    camera.position,\n    vector.sub(camera.position).normalize()\n  );\n  let intersects = rayCaster.intersectObjects(scene.children);\n  if (intersects.length > 0) {\n    let selected = intersects[0]; //取第一个物体\n    console.log(\"x坐标:\" + selected.point.x);\n    console.log(\"y坐标:\" + selected.point.y);\n    console.log(\"z坐标:\" + selected.point.z);\n  }\n}\n\nfunction waitSeconds(seconds = 0) {\n  return new Promise((resolve) => setTimeout(resolve, seconds * 1000));\n}\n\nlet count = 0;\nasync function iterativeScene() {\n  for (;;) {\n    count++;\n    initPipeConf();\n    await waitSeconds(2);\n    resMgr.dispose();\n    await waitSeconds(1);\n    // console.log(count);\n    // console.log(data.base3D.renderer.info.memory);\n  }\n}\n</script>\n\n<style scoped>\n#sceneContainer {\n  width: 100%;\n  height: 100%;\n}\n\n#sceneContainer,\ncanvas {\n  position: fixed;\n  top: 0;\n  left: 0;\n  outline: none;\n}\n</style>\n"],"names":["THREE.TubeGeometry","THREE.TextureLoader","THREE.RepeatWrapping","THREE.MeshPhongMaterial","THREE.Mesh","THREE.Vector3","THREE.CatmullRomCurve3"],"mappings":"geAYY,EAAS,IACR,EAAS,IAGtB,KAAM,GAAiB,EAAI,MAIrB,EAAY,CAChB,CAAC,IAAK,IAAK,GACX,CAAC,IAAK,GAAI,GACV,CAAC,EAAG,EAAG,GACP,CAAC,GAAI,GAAI,GACT,CAAC,GAAI,GAAI,IA0CX,GAAI,GACJ,KAAM,GAAS,GAAI,GACb,EAAQ,EAAO,MAAM,KAAK,GAEhC,GAAI,GAAO,EAAS,CAClB,OAAQ,KAGV,EAAU,IAAM,CACd,IACA,IACA,MAGF,YAAqB,CACnB,EAAK,OAAS,GAAI,GAAO,EAAe,OACxC,EAAe,SAAS,EAAK,OAAO,OAItC,WAAiB,EAAM,CACrB,GAAQ,KACR,EAAQ,OAAO,EAAI,CAAE,GAAO,GAAK,EAEjC,sBAAsB,GAGxB,YAAwB,CACtB,KAAM,GAAkB,CACtB,OAAQ,EACR,MAAO,QACP,OAAQ,EACR,QAAS,IAIL,EAAO,CACX,OAAQ,EACR,QAAS,oBACT,OAAQ,KAGJ,CAAE,QAAS,EAAc,KAAM,GAAU,EAAU,GACnD,CAAE,QAAS,EAAc,KAAM,GAAU,EAAU,GACzD,SAAU,EACV,EAAK,OAAO,MAAM,IAAI,EAAM,IAC5B,EAAK,OAAO,MAAM,IAAI,EAAM,IA2HrB,CAAE,eAAc,gBA+EzB,WAAmB,EAAM,CACvB,KAAM,GAAO,EAAW,EAAK,QACvB,EAAW,EACf,GAAIA,GAAmB,EAAM,IAAK,EAAK,OAAQ,GAAI,KAG/C,EAAgB,GAAIC,GAC1B,GAAI,GAEJ,AAAI,EAAK,UAAY,OACnB,GAAU,EAAc,KAAK,EAAK,SAGlC,EAAQ,MAAQC,EAChB,EAAQ,MAAQA,EAGhB,EAAQ,OAAO,IAAI,GAAI,GAIvB,EAAW,EACT,GAAIC,GAAwB,CAC1B,IAAK,EACL,YAAa,GACb,UAAW,OAYf,EAAW,EACT,GAAIA,GAAwB,CAE1B,MAAO,EAAK,MACZ,YAAa,GACb,QAAS,EAAK,QACd,WAAY,MAIlB,KAAM,GAAO,EAAM,GAAIC,GAAW,EAAU,IAE5C,SAAK,SAAS,EAAI,KAAK,GAAK,GAErB,CAAE,UAAS,QAGpB,WAAoB,EAAW,CAC7B,SAAY,EAAU,IAAI,AAAC,GAAU,GAAIC,GAAc,GAAG,IAEnD,GAAIC,GAAuB,GAyBpC,WAAqB,EAAU,EAAG,CAChC,MAAO,IAAI,SAAQ,AAAC,GAAY,WAAW,EAAS,EAAU,MAIhE,kBAAgC,CAC9B,OAEE,IACA,KAAM,GAAY,GAClB,EAAO,UACP,KAAM,GAAY"}
import{fu as f,hv as p}from"./externalRenderers.e9b2a64d.js";function i(t){var r;return Array.isArray(t)?(r=t[0])==null?void 0:r.spatialReference:t==null?void 0:t.spatialReference}function l(t){return t&&(Array.isArray(t)?t.map(l):t.toJSON?t.toJSON():t)}function u(t){return Array.isArray(t)?t.map(r=>f(r)):f(t)}function w(t,r){let e;return Array.isArray(t)?e=t:(e=[],e.push(t),r!=null&&e.push(r)),e}let s;async function d(){return s||(s=p("geometryEngineWorker",{strategy:"distributed"})),s}async function n(t,r){return(await d()).invoke("executeGEOperation",{operation:t,parameters:l(r)})}async function A(t,r){return u(await n("clip",[i(t),t,r]))}async function h(t,r){return u(await n("cut",[i(t),t,r]))}function v(t,r){return n("contains",[i(t),t,r])}function x(t,r){return n("crosses",[i(t),t,r])}function R(t,r,e){return n("distance",[i(t),t,r,e])}function E(t,r){return n("equals",[i(t),t,r])}function O(t,r){return n("intersects",[i(t),t,r])}function S(t,r){return n("touches",[i(t),t,r])}function b(t,r){return n("within",[i(t),t,r])}function J(t,r){return n("disjoint",[i(t),t,r])}function j(t,r){return n("overlaps",[i(t),t,r])}function k(t,r,e){return n("relate",[i(t),t,r,e])}function L(t){return n("isSimple",[i(t),t])}async function N(t){return u(await n("simplify",[i(t),t]))}async function q(t,r){return u(await n("difference",[i(t),t,r]))}async function D(t,r){return u(await n("symmetricDifference",[i(t),t,r]))}async function G(t,r){return u(await n("intersect",[i(t),t,r]))}async function I(t,r=null){const e=w(t,r);return u(await n("union",[i(e),e]))}async function W(t,r,e,a,c,o){return u(await n("offset",[i(t),t,r,e,a,c,o]))}async function $(t,r,e,a=!1){const c=[i(t),t,r,e,a];return u(await n("buffer",c))}async function z(t,r,e,a,c,o){const y=[i(t),t,r,e,a,c,o];return u(await n("geodesicBuffer",y))}function m(t){return"xmin"in t?t.center:"x"in t?t:t.extent.center}async function B(t,r,e){var a;if(t==null)throw new Error("Illegal Argument Exception");const c=t.spatialReference;e=(a=e)!=null?a:m(t);const o=t.constructor.fromJSON(await n("rotate",[c,t,r,e]));return o.spatialReference=c,o}async function F(t,r,e,a){return u(await n("generalize",[i(t),t,r,e,a]))}async function K(t,r,e){return u(await n("densify",[i(t),t,r,e]))}async function M(t,r,e,a=0){return u(await n("geodesicDensify",[i(t),t,r,e,a]))}function P(t,r){return n("planarArea",[i(t),t,r])}function U(t,r){return n("planarLength",[i(t),t,r])}function V(t,r,e){return n("geodesicArea",[i(t),t,r,e])}function C(t,r,e){return n("geodesicLength",[i(t),t,r,e])}export{S as A,D as E,U as F,F as G,W as I,N as J,V as K,C as M,j as O,K as P,q as R,J as S,M as U,$ as V,P as W,z as b,E as d,O as g,k as h,G as j,I as k,A as l,R as m,v as p,B as q,L as v,x as w,b as x,h as y};
//# sourceMappingURL=geometryEngineAsync.47678974.js.map

{"version":3,"file":"rightAngleTube.682528ec.js","sources":["../../src/components/rightAngleTube.vue"],"sourcesContent":["<!--\n@name:\n@version:1.0\n@description: https://discourse.threejs.org/t/profiledcontourgeometry/2330\n@author: parabellum\n@time: 2022-03-25 11:32:56\n-->\n<template>\n  <div id=\"sceneContainer\" ref=\"sceneContainer\"></div>\n</template>\n\n<script setup>\nimport { ref, reactive, onMounted } from \"vue\";\nimport Base3D from \"../utils/base3D\";\nimport threeUniversal from \"../utils/threeUniversal\";\nimport * as THREE from \"three\";\nlet data = reactive({\n  base3d: {},\n});\n\nlet sceneContainer = ref(null);\n\nlet profileShape = new THREE.Shape();\nprofileShape.absarc(0, 0, 5, 0, Math.PI * 2);\n\n// 管线数组,每两个表示一个点\nlet tubeContour = [-40, 50, 0, 50, 50, 50, 50, 0];\n\nvar profileShape1 = new THREE.Shape();\n// profileShape1.moveTo(0, 0);\n// profileShape1.lineTo(0, 1);\nprofileShape1.absarc(1, 1, 0.5, Math.PI, Math.PI * 0.5);\n// profileShape1.lineTo(1, 0);\n\nvar contour1 = [\n  new THREE.Vector2(0, 0),\n  new THREE.Vector2(1, 1),\n  new THREE.Vector2(2, 1),\n  new THREE.Vector2(2, 0),\n  new THREE.Vector2(1, -1),\n];\n\nlet contour = [\n  new THREE.Vector2(-40, 50),\n  new THREE.Vector2(0, 50),\n  new THREE.Vector2(50, 50),\n  new THREE.Vector2(50, 0),\n  /*  new THREE.Vector3(-40, 50, 100),\n  new THREE.Vector3(0, 50, 200),\n  new THREE.Vector3(50, 50, 20),\n  new THREE.Vector3(50, 0, 70),*/\n];\n\nonMounted(() => {\n  data.base3d = new Base3D(sceneContainer.value);\n  threeUniversal.addFloor(data.base3d.scene);\n  handleContour();\n});\n\n/**\n *处理管线顶点\n */\nfunction handleContour() {\n  /* for (let i = 0; i < tubeContour.length; i += 2)\n    contour.push(\n      new THREE.Vector2(\n        tubeContour.slice(i, i + 2)[0],\n        tubeContour.slice(i, i + 2)[1]\n      )\n    );*/\n  init();\n}\n\nfunction init() {\n  let geometry1 = ProfiledContourGeometry(profileShape, contour, false, true);\n  geometry1.rotateX(-Math.PI * 0.5);\n\n  let fullProfile1 = new THREE.Mesh(\n    geometry1,\n    new THREE.MeshBasicMaterial({\n      color: \"aqua\",\n      opacity: 0.4,\n      //   wireframe: true\n      depthWrite: false,\n      depthTest: false,\n      transparent: true,\n      side: THREE.DoubleSide,\n    })\n  );\n  fullProfile1.position.set(-7, 1, -5);\n  data.base3d.scene.add(fullProfile1);\n\n  /*  let geometry2 = ProfiledContourGeometry(profileShape, contour, false, true);\n  let fullProfile2 = new THREE.Mesh(\n    geometry2,\n    new THREE.MeshBasicMaterial({\n      color: \"yellow\",\n      wireframe: true, // 线框模式\n    })\n  );\n  fullProfile2.position.set(90, 1, -5);\n  // fullProfile2.position.set(-7, 1, -5);\n  data.base3d.scene.add(fullProfile2);*/\n\n  var geometry2 = ProfiledContourGeometry(profileShape1, contour1, false, true);\n  // geometry2.rotateX(-Math.PI * 0.5);\n  var fullProfile2 = new THREE.Mesh(\n    geometry2,\n    new THREE.MeshLambertMaterial({\n      color: \"red\",\n      wireframe: false,\n    })\n  );\n  // data.base3d.scene.add(fullProfile2);\n}\n\n/**\n * 异形的Geometry\n * @param profileShape\n * @param contour\n * @param contourClosed\n * @param openEnded\n * @returns {BufferGeometry}\n * @constructor\n */\nfunction ProfiledContourGeometry(\n  profileShape,\n  contour,\n  contourClosed,\n  openEnded\n) {\n  contourClosed = contourClosed !== undefined ? contourClosed : true;\n  openEnded = openEnded !== undefined ? openEnded : false;\n  openEnded = contourClosed === true ? false : openEnded;\n\n  let profileGeometry = new THREE.ShapeBufferGeometry(profileShape);\n  let flipProfileGeometry = flipShapeGeometry(profileGeometry);\n  profileGeometry.rotateX(Math.PI * 0.5);\n  let profile = profileGeometry.attributes.position;\n\n  let addEnds = openEnded === false ? 2 : 0;\n  let profilePoints = new Float32Array(\n    profile.count * (contour.length + addEnds) * 3\n  );\n\n  let endProfiles = [];\n\n  for (let i = 0; i < contour.length; i++) {\n    let v1 = new THREE.Vector2().subVectors(\n      contour[i - 1 < 0 ? contour.length - 1 : i - 1],\n      contour[i]\n    );\n    let v2 = new THREE.Vector2().subVectors(\n      contour[i + 1 === contour.length ? 0 : i + 1],\n      contour[i]\n    );\n\n    /*   let v1 = new THREE.Vector3().subVectors(\n      contour[i - 1 < 0 ? contour.length - 1 : i - 1],\n      contour[i]\n    );\n    let v2 = new THREE.Vector3().subVectors(\n      contour[i + 1 === contour.length ? 0 : i + 1],\n      contour[i]\n    );\n\n    let angle = v2.angleTo(v1);\n    console.log(angle);*/\n\n    console.log(v2.angle(), v1.angle());\n    let angle = v2.angle() - v1.angle();\n    let halfAngle = angle * 0.5;\n\n    let hA = halfAngle;\n    let tA = v2.angle() + Math.PI * 0.5;\n    if (!contourClosed) {\n      if (i == 0 || i == contour.length - 1) {\n        hA = Math.PI * 0.5;\n      }\n      if (i == contour.length - 1) {\n        tA = v1.angle() - Math.PI * 0.5;\n      }\n    }\n\n    let shift = Math.tan(hA - Math.PI * 0.5);\n    let shiftMatrix = new THREE.Matrix4().set(\n      1,\n      0,\n      0,\n      0,\n      -shift,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1\n    );\n\n    let tempAngle = tA;\n    let rotationMatrix = new THREE.Matrix4().set(\n      Math.cos(tempAngle),\n      -Math.sin(tempAngle),\n      0,\n      0,\n      Math.sin(tempAngle),\n      Math.cos(tempAngle),\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1\n    );\n\n    let translationMatrix = new THREE.Matrix4().set(\n      1,\n      0,\n      0,\n      contour[i].x,\n      0,\n      1,\n      0,\n      contour[i].y,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1\n    );\n\n    let cloneProfile = profile.clone();\n    cloneProfile.applyMatrix4(shiftMatrix);\n    cloneProfile.applyMatrix4(rotationMatrix);\n    cloneProfile.applyMatrix4(translationMatrix);\n\n    profilePoints.set(cloneProfile.array, cloneProfile.count * i * 3);\n    if (openEnded === false && (i === 0 || i === contour.length - 1)) {\n      endProfiles.push(cloneProfile);\n    }\n  }\n\n  endProfiles.forEach((ep, idx) => {\n    profilePoints.set(ep.array, ep.count * (contour.length + idx) * 3);\n  });\n\n  let fullProfileGeometry = new THREE.BufferGeometry();\n  fullProfileGeometry.setAttribute(\n    \"position\",\n    new THREE.BufferAttribute(profilePoints, 3)\n  );\n  let index = [];\n\n  let lastCorner =\n    contourClosed === false ? contour.length - 1 : contour.length;\n  for (let i = 0; i < lastCorner; i++) {\n    for (let j = 0; j < profile.count; j++) {\n      let currCorner = i;\n      let nextCorner = i + 1 === contour.length ? 0 : i + 1;\n      let currPoint = j;\n      let nextPoint = j + 1 === profile.count ? 0 : j + 1;\n\n      let a = nextPoint + profile.count * currCorner;\n      let b = currPoint + profile.count * currCorner;\n      let c = currPoint + profile.count * nextCorner;\n      let d = nextPoint + profile.count * nextCorner;\n\n      index.push(a, b, d);\n      index.push(b, c, d);\n    }\n  }\n\n  if (openEnded === false) {\n    // add indices from profile geometries\n    flipProfileGeometry.index.array.forEach((i) => {\n      index.push(i + profile.count * contour.length);\n    });\n    profileGeometry.index.array.forEach((i) => {\n      index.push(i + profile.count * (contour.length + 1));\n    });\n  }\n\n  fullProfileGeometry.setIndex(index);\n  fullProfileGeometry.computeVertexNormals();\n\n  return fullProfileGeometry;\n}\n\nfunction flipShapeGeometry(shapeGeometry) {\n  let flipGeom = shapeGeometry.clone();\n  for (let i = 0; i < flipGeom.attributes.position.count; i++) {\n    flipGeom.attributes.position.array[i * 3] *= -1;\n  }\n  flipGeom.attributes.position.needsUpdate = true;\n\n  let index = flipGeom.index.array;\n  for (let i = 0; i < index.length; i += 3) {\n    let tmp = index[i + 1];\n    let v3 = index[i + 2];\n    index[i + 1] = index[i + 2];\n    index[i + 2] = tmp;\n  }\n  flipGeom.computeVertexNormals();\n  return flipGeom;\n}\n</script>\n\n<style scoped></style>\n"],"names":["THREE.Shape","THREE.Vector2","THREE.Mesh","THREE.MeshBasicMaterial","THREE.DoubleSide","THREE.MeshLambertMaterial","THREE.ShapeBufferGeometry","THREE.Matrix4","THREE.BufferGeometry","THREE.BufferAttribute"],"mappings":"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"}